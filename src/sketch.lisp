;;;; sketch.lisp

(in-package #:sketch)

;;; "sketch" goes here. Hacks and glory await!

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;                                                                  ;;;
;;;     _|_|_|  _|    _|  _|_|_|_|  _|_|_|_|_|    _|_|_|  _|    _|   ;;;
;;;   _|        _|  _|    _|            _|      _|        _|    _|   ;;;
;;;     _|_|    _|_|      _|_|_|        _|      _|        _|_|_|_|   ;;;
;;;         _|  _|  _|    _|            _|      _|        _|    _|   ;;;
;;;   _|_|_|    _|    _|  _|_|_|_|      _|        _|_|_|  _|    _|   ;;;
;;;                                                                  ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Sketch class

(eval-when (:compile-toplevel :load-toplevel :execute)
  ;; Names of slots that code later in this file needs
  (defparameter *default-slots*
    '(title width height fullscreen copy-pixels y-axis)))

(defmacro define-sketch-class ()
  `(defclass sketch ()
     ((context)
      (window)
      (viewport)
      (blending :initform (make-blending-params))
      (%env)
      (%restart :initform t)
      (title :initform "Sketch" :reader sketch-title :initarg :title)
      (width :initform 400 :reader sketch-width :initarg :width)
      (height :initform 400 :reader sketch-height :initarg :height)
      (fullscreen :initform nil :reader sketch-fullscreen :initarg :fullscreen)
      (copy-pixels :initform nil :accessor sketch-copy-pixels :initarg :copy-pixels)
      (y-axis :initform :down :reader sketch-y-axis :initarg :y-axis)
      (thread :initform nil :reader sketch-thread :initarg :thread)
      (to-thread-chanl :initform nil :reader to-thread-chanl)
      (from-thread-chanl :initform nil :reader from-thread-chanl))))

(define-sketch-class)

;;; Non trivial sketch writers

(defmacro define-sketch-writer (slot &body body)
  `(defmethod (setf ,(alexandria:symbolicate 'sketch- slot)) (value (instance sketch))
     (setf (slot-value instance ',slot) value)
     (let ((win (slot-value instance 'window)))
       ,@body)))

(defgeneric (setf sketch-title) (value instance))
(defgeneric (setf sketch-width) (value instance))
(defgeneric (setf sketch-height) (value instance))
(defgeneric (setf sketch-fullscreen) (value instance))
(defgeneric (setf sketch-y-axis) (value instance))

(define-sketch-writer title
  (setf (surface-title win) (slot-value instance 'title)))

(define-sketch-writer width
  (with-slots (width height) instance
    (let ((dimensions (list width height)))
      (setf (viewport-dimensions (current-viewport)) dimensions)
      (setf (surface-dimensions win) dimensions))))

(define-sketch-writer height
  (with-slots (width height) instance
    (let ((dimensions (list width height)))
      (setf (viewport-dimensions (current-viewport)) dimensions)
      (setf (surface-dimensions win) dimensions))))

(define-sketch-writer fullscreen
  (setf (surface-fullscreen-p win) (slot-value instance 'fullscreen)))

(define-sketch-writer y-axis
  (declare (ignore win))
  (with-slots ((env %env) width height y-axis) instance
    (setf (env-view-matrix env)
          (if (eq y-axis :down)
              (kit.glm:ortho-matrix 0 width height 0 -1 1)
              (kit.glm:ortho-matrix 0 width 0 height -1 1)))))

;;; Generic functions

(defgeneric prepare (instance &key &allow-other-keys)
  (:documentation "Generated by DEFSKETCH.")
  (:method-combination progn :most-specific-last))

(defgeneric setup (instance &key &allow-other-keys)
  (:documentation "Called before creating the sketch window.")
  (:method ((instance sketch) &key &allow-other-keys) ()))

(defgeneric draw (instance &key &allow-other-keys)
  (:documentation "Called repeatedly after creating the sketch window,
used for drawing, 60fps.")
  (:method ((instance sketch) &key &allow-other-keys) ()))

;;; Rendering

(defvar *last-error* nil)

(defmacro gl-catch (error-color &body body)
  `(handler-case
       (progn
         ,@body)
     (error (e)
       (progn
         (push e *last-error*)
         (background ,error-color)
         (with-font (make-error-font)
           (with-identity-matrix
             (text "ERROR" 20 20)
             (text (format nil "~a" e) 20 40)
             (text "Click for restarts." 20 60)))
         (setf %restart t
               (env-red-screen *env*) t)))))



;;; Default events

;; {TODO} both of these

;; (defmethod kit.sdl2:close-window :before ((instance sketch))
;;   (with-environment (slot-value instance '%env)
;;     (loop for resource being the hash-values of (env-resources *env*)
;;        do (free-resource resource))))

;; (defmethod kit.sdl2:close-window :after ((instance sketch))
;;   (when (and *build* (not (kit.sdl2:all-windows)))
;;     (sdl2-ttf:quit)
;;     (kit.sdl2:quit)))

;;; DEFSKETCH helpers

(defun first-two (list)
  (list (first list) (second list)))

(defun default-slot-p (slot-or-binding)
  (let ((defaults *default-slots*))
    (typecase slot-or-binding
      (list (member (car slot-or-binding) defaults))
      (t (member slot-or-binding defaults)))))

(defun custom-bindings (&optional bindings)
  (remove-if (lambda (binding)
               (member (car binding) *default-slots*))
             bindings))

(defun intern-accessor (name)
  (intern (string (alexandria:symbolicate 'sketch- name)) :sketch))

(defun binding-accessor (sketch binding)
  (if (default-slot-p binding)
      (intern-accessor (car binding))
      (or (cadr (member :accessor (cddr binding)))
          (alexandria:symbolicate sketch '- (car binding)))))

(defun make-slot-form (sketch binding)
  `(,(car binding)
     :initarg ,(alexandria:make-keyword (car binding))
     :accessor ,(binding-accessor sketch binding)))

;;; DEFSKETCH channels

(defun channel-binding-p (binding)
  (and (consp (cadr binding)) (eql 'in (caadr binding))))

(defun make-channel-observer (sketch binding)
  `(define-channel-observer
     (with-slots (window) sketch
       (when window
         (setf (,(binding-accessor sketch binding) window) ,(cadr binding))))))

(defun make-channel-observers (sketch bindings)
  (mapcar (lambda (binding)
            (when (channel-binding-p binding)
              (make-channel-observer sketch binding)))
          bindings))

(defun replace-channels-with-values (bindings)
  (loop for binding in bindings
     collect (list (car binding)
                   (if (channel-binding-p binding)
                       (caddr (cadr binding))
                       (cadr binding)))))

;;; DEFSKETCH bindings

(defun sketch-bindings-to-slots (sketch bindings)
  (mapcar (lambda (x) (make-slot-form sketch x))
          (remove-if (lambda (x)
                       (member (car x) *default-slots*))
                     bindings)))

;;; DEFSKETCH setf instructions

(defun make-window-parameter-setf ()
  `(setf ,@(mapcan (lambda (slot)
                     `((,(intern-accessor slot) instance) ,slot))
                   *default-slots*)))

(defun make-custom-slots-setf (sketch bindings)
  `(setf ,@(mapcan (lambda (binding)
                     `((,(binding-accessor sketch binding) instance) ,(car binding)))
                   bindings)))

(defun make-reinitialize-setf ()
  `(setf ,@(mapcan (lambda (slot)
                     `((,(intern-accessor slot) instance)
                       (,(intern-accessor slot) instance)))
                   *default-slots*)))

;;; DEFSKETCH macro

(defun prepare-binding (binding)
  (destructuring-bind (name value)
      (first-two binding)
    (list name (if (default-slot-p name)
                   `(if (getf initargs ,(alexandria:make-keyword name))
                        (slot-value instance ',name)
                        ,value)
                   `(or (getf initargs ,(alexandria:make-keyword name)) ,value)))))

(defmacro defsketch (sketch-name bindings &body body)
  (let ((redefines-sketch-p (find-class sketch-name nil))
        (def-form `((defclass ,sketch-name (sketch)
                      ,(sketch-bindings-to-slots `,sketch-name bindings))))
        (default-slots
         (remove-if (lambda (x) (find x bindings :key #'first))
                    *default-slots*)))
    `(progn
       ;; defined here or lower down depending on whether the class
       ;; already exists
       ,@(unless redefines-sketch-p def-form)

       ,@(remove nil (make-channel-observers sketch-name bindings))

       (defmethod prepare
           progn
         ((instance ,sketch-name) &rest initargs &key &allow-other-keys)
         (declare (ignorable initargs))
         (let* (;; default slots
                ,@(loop :for slot :in default-slots :collect
                     (list slot `(slot-value instance ',slot)))
                ;; custom slots
                ,@(mapcar #'prepare-binding
                          (replace-channels-with-values bindings)))
           (declare (ignorable ,@*default-slots*))
           ,(make-window-parameter-setf)
           ,(make-custom-slots-setf sketch-name (custom-bindings bindings)))
         (setf (env-y-axis-sgn (slot-value instance '%env))
               (if (eq (slot-value instance 'y-axis) :down)
                   +1
                   -1)))

       ;; see note for defclass above
       ,@(when redefines-sketch-p def-form)

       (defmethod draw ((instance ,sketch-name) &key &allow-other-keys)
         (with-accessors ,(mapcar (lambda (x) (list x (intern-accessor x)))
                                  *default-slots*)
             instance
           (with-slots ,(mapcar #'car bindings) instance
             ,@body)))

       (find-class ',sketch-name))))
